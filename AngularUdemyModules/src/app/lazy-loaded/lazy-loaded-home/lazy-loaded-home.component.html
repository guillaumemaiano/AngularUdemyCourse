<h1>How to lazily load an Angular module</h1>
<ol>
    <li>Remove any existing <span class="code">import</span> statement for the module anywhere in the project</li>
    <li>In the AppRoutingModule, define a Route in the '<span class="code">routes</span>' array to specify when to load up that module</li>
    <li>In the lazy loaded module's Routing file, edit the '<span class='code'>path</span>' of each route to be relative to the AppRoutingModule-defined path.</li>
</ol>
<div class="ui message">
    <h2>Use some JS to load the LazyLoaded element</h2>
    <p>Note how instead of component, we use '<span class="code">loadChildren</span>', and a callback.</p>
    <p>Assumption: we created a lazy loaded module called "lazy-loaded"...</p>
    <div class='code'>
       {{ '{ ' }} path: 'lazy-loaded', 
          loadChildren: () => import('./lazy-loaded/lazy-loaded.module').then(m => m.LazyLoadedModule)
        {{'}'}}
    </div>
</div>

<div>
    <h2>I just got an unplanned detailed course on Angular Networking.</h2>
    <p>To sum the idea up: forgetting to add --routing during module generation adds another task, creation of the module-routing.ts file. The content is straightforward: a ngModule directive, an export, a few exports, and any relevant route. Then we need to import the routing module into the module, and we're done.</p>
    <ol>
        <li>Create <span class='code'>my-module-routing.ts</span></li>
        <li>Fill content: imports, exports and routes</li>
        <li>Import the module routing into <span class='code'>my-module.ts</span></li>
    </ol>
    <br>
    Or, you know, not forget the <span class='code'>--routing</span> argument when generating modules...
</div>